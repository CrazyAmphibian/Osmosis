local nodes={}

local plists={}
local p_min=0
local p_max=0

local typeing_getstring -- gets the string to modify. this would return something like return a[1]
local typeing_setstring -- sets the string to modify. this would then go a[1]=str
local typeing_identifier="" --string that is used for ID for text flashing or stuff
--we do this to make it quite dynamic and easy to modify things.

local MAX_TUMBNAILS=10
local thumbnailbuffers={}

local function assoc_generate_thumbnail(imagename)
	for i=1,#thumbnailbuffers do
		if thumbnailbuffers[i].img==imagename then return thumbnailbuffers[i].tex end
	end
	
	local imgdat=imagedata[imagename]
	
	local f,e=io.open("images/"..imagename ,"rb")
	if not f then print(imagename,e) imgdat.error=true return end
	local rawd=image.load(f:read("*a"))
	f:close()
	if not rawd then print(imagename,"LOAD FALIURE") imgdat.error=true return end

	--config.thumbnailsize

	--local start2=os.clock()

	imgdat.width=rawd.width
	imgdat.height=rawd.height

	local buffer={}
	local width=1
	if rawd.type==image.TYPE_RGB then width=3 end
	if rawd.type==image.TYPE_RGBA then width=4 end
	if rawd.type==image.TYPE_LUMINANCE then width=1 end
	if rawd.type==image.TYPE_LUMINANCE_ALPHA then width=2 end

	local reduce=math.ceil(math.max(imgdat.width,imgdat.height)/(config.thumbnailsize))
	local nw,nh=math.floor(imgdat.width/reduce), math.floor(imgdat.height/reduce)

	local ow=imgdat.width

	--print(imgdat.width,imgdat.height,nw,nh,reduce,config.thumbnailsize)
	for h=0,nh-1 do
		--h=h
		for w=0,nw-1 do
			--w=w
			buffer[#buffer+1]=string.sub(rawd.buffer,(h*width*ow+w*width)*reduce+1,(h*width*ow+w*width)*reduce+width)
		end
	end

	--local start3=os.clock()
	local nubuf=table.concat(buffer)

	imgdat.thumbnailimagetype=rawd.type
	imgdat.thumbnailw=nw
	imgdat.thumbnailh=nh


imgdat.thumbnailbuffer=nubuf

local tc= gui.new_texture("IMAGEP_"..imagename, imgdat.thumbnailw,imgdat.thumbnailh, imgdat.thumbnailimagetype, nubuf , false)
if tc==true then
	table.insert(thumbnailbuffers,1,{img=imagename,tex="IMAGEP_"..imagename})
	if thumbnailbuffers[MAX_TUMBNAILS+1] then
		gui.delete_texture( thumbnailbuffers[MAX_TUMBNAILS+1].tex)
		thumbnailbuffers[MAX_TUMBNAILS+1]=nil
	end
	return "IMAGEP_"..imagename
end
print("associative thumbnail failed to generate")
return nil
	
end

function init(self)
	msg.post(".", "acquire_input_focus")
end


function update(self, dt)
	for i=1,#nodes do
		local node=nodes[i]
		gui.delete_node(node.node)
		nodes[i]=nil
	end

	if  programdata.screen ~="associations" then return end

	local _scale=config.guiscale
	--[[
	assoc.images = {}
	assoc.ordered = false
	assoc.name = ""
	assoc.tags = {}
	]]
	local yoff=0.0

	node=gui.new_box_node(vmath.vector3(0,programdata.height,0), vmath.vector3(programdata.width,_scale*(45+128),0))
	gui.set_pivot(node, gui.PIVOT_NW)
	gui.set_color(node, vmath.vector3(.2))
	nodes[#nodes+1]={node=node}
	
	if programdata.associatedimage then
		local t=assoc_generate_thumbnail(programdata.associatedimage)
		if t then
			local img=programdata.associatedimage
			local is= 128/math.max(imagedata[img].height,imagedata[img].width)

			node=gui.new_text_node(vmath.vector3(_scale*15,programdata.height-_scale*25+yoff,0), programdata.associatedimage:truncate(50))
			gui.set_pivot(node, gui.PIVOT_SW)
			gui.set_font(node, "sysstd")
			gui.set_scale(node, vmath.vector3(_scale))
			nodes[#nodes+1]={node=node}
			
			node=gui.new_box_node(vmath.vector3(_scale*15,programdata.height-_scale*25+yoff,0), vmath.vector3(_scale*128,_scale*128,0))
			gui.set_pivot(node, gui.PIVOT_NW)
			gui.set_color(node,  vmath.vector3(.15))
			nodes[#nodes+1]={node=node}
			pnode=node

			node=gui.new_box_node(vmath.vector3(64*_scale,-64*_scale,0), vmath.vector3(_scale*is*imagedata[img].width,_scale*is*imagedata[img].height,0))
			gui.set_pivot(node, gui.PIVOT_CENTER)
			gui.set_texture(node,  t)
			gui.set_parent(node,pnode)

			node=gui.new_text_node(vmath.vector3(_scale*15,programdata.height-_scale*(128+25)+yoff,0), "SELECTED")
			gui.set_pivot(node, gui.PIVOT_NW)
			gui.set_font(node, "sysstd")
			gui.set_scale(node,  vmath.vector3(_scale))
			nodes[#nodes+1]={node=node}
		end
	end
	if programdata.assocfilterimage then
		local t=assoc_generate_thumbnail(programdata.assocfilterimage)
		if t then
			local img=programdata.assocfilterimage
			local is= 128/math.max(imagedata[img].height,imagedata[img].width)

			node=gui.new_text_node(vmath.vector3(programdata.width-_scale*15,programdata.height-_scale*25+yoff,0), programdata.assocfilterimage:truncate(50))
			gui.set_pivot(node, gui.PIVOT_SE)
			gui.set_font(node, "sysstd")
			gui.set_scale(node, vmath.vector3(_scale))
			nodes[#nodes+1]={node=node}
			
			node=gui.new_box_node(vmath.vector3(programdata.width-_scale*15,programdata.height-_scale*25+yoff,0), vmath.vector3(_scale*128,_scale*128,0))
			gui.set_pivot(node, gui.PIVOT_NE)
			gui.set_color(node,  vmath.vector3(.15))
			nodes[#nodes+1]={node=node}
			pnode=node

			node=gui.new_box_node(vmath.vector3(-64*_scale,-64*_scale,0), vmath.vector3(_scale*is*imagedata[img].width,_scale*is*imagedata[img].height,0))
			gui.set_pivot(node, gui.PIVOT_CENTER)
			gui.set_texture(node,  t)
			gui.set_parent(node,pnode)

			node=gui.new_text_node(vmath.vector3(programdata.width-_scale*15,programdata.height-_scale*(128+25)+yoff,0), "FILTER")
			gui.set_pivot(node, gui.PIVOT_NE)
			gui.set_font(node, "sysstd")
			gui.set_scale(node,  vmath.vector3(_scale))
			nodes[#nodes+1]={node=node}
		end
	end


	yoff=yoff-(45+128)*_scale

	
	for i=1,#associations do
		local assoc=associations[i]
		local node

		local isselected=typeing_identifier=="ASSOCIATION_\000_"..i
		
		node=gui.new_box_node(vmath.vector3(_scale*10,programdata.height-_scale*10+yoff,0), vmath.vector3(programdata.width-_scale*20,_scale*(20+128+20+50),0))
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_color(node, vmath.vector3(.2))
		nodes[#nodes+1]={node=node}
		
		node=gui.new_box_node(vmath.vector3(_scale*15,programdata.height-_scale*15+yoff,0), vmath.vector3(programdata.width-_scale*30,_scale*(30),0))
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_color(node, vmath.vector3(isselected and .05 or .1))
		nodes[#nodes+1]={node=node,clicked=function()
			typeing_getstring=function() return assoc.name end
			typeing_setstring=function(s) assoc.name=s end
			typeing_identifier="ASSOCIATION_\000_"..i
		end,clickoffed=function()
			if isselected then
				typeing_getstring=nil
				typeing_setstring=nil
				typeing_identifier=""
			end
		end}
		local pnode=node
		node=gui.new_text_node(vmath.vector3(0,0,0), assoc.name .. (((os.clock()%1>=.5) and isselected) and "|" or "") )
		gui.set_font(node, "sysoneandhalf")
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_parent(node,pnode)
		

		yoff=yoff-40*_scale
		
		local xoff=0
		for i=1,4 do
			local img=assoc.images[i]
			if not img then break end

			local tex=assoc_generate_thumbnail(img)
			if not tex then break end
			
			local is= 128/math.max(imagedata[img].height,imagedata[img].width)
			node=gui.new_box_node(vmath.vector3(_scale*45+xoff,programdata.height-_scale*15+yoff,0), vmath.vector3(_scale*128,_scale*128,0))
			gui.set_pivot(node, gui.PIVOT_NW)
			gui.set_color(node,  vmath.vector3(.15))
			nodes[#nodes+1]={node=node}
			pnode=node
			
			node=gui.new_box_node(vmath.vector3(64*_scale,-64*_scale,0), vmath.vector3(_scale*is*imagedata[img].width,_scale*is*imagedata[img].height,0))
			gui.set_pivot(node, gui.PIVOT_CENTER)
			gui.set_texture(node,  tex)
			gui.set_parent(node,pnode)
			xoff=xoff+138*_scale
			
		end

		yoff=yoff-138*_scale

		-- add
		node=gui.new_box_node(vmath.vector3(_scale*15,programdata.height-_scale*15+yoff,0), vmath.vector3(_scale*200,_scale*(30),0))
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_color(node, vmath.vector3(.1))
		nodes[#nodes+1]={node=node,clicked=function() end}
		pnode=node
		
		node=gui.new_text_node(vmath.vector3(0,0,0), "add active image")
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_font(node, "sysoneandhalf")
		gui.set_scale(node, vmath.vector3(_scale))
		gui.set_parent(node,pnode)
		
		--edit
		node=gui.new_box_node(vmath.vector3(_scale*225,programdata.height-_scale*15+yoff,0), vmath.vector3(_scale*200,_scale*(30),0))
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_color(node, vmath.vector3(.1))
		nodes[#nodes+1]={node=node,clicked=function() end}
		local pnode=node

		node=gui.new_text_node(vmath.vector3(0,0,0), "edit")
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_font(node, "sysoneandhalf")
		gui.set_scale(node, vmath.vector3(_scale))
		gui.set_parent(node,pnode)
		--delete
		node=gui.new_box_node(vmath.vector3(_scale*435,programdata.height-_scale*15+yoff,0), vmath.vector3(_scale*200,_scale*(30),0))
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_color(node, vmath.vector3(.1))
		nodes[#nodes+1]={node=node,clicked=function() table.remove(associations,i) end}
		local pnode=node

		node=gui.new_text_node(vmath.vector3(0,0,0), "delete")
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_font(node, "sysoneandhalf")
		gui.set_scale(node, vmath.vector3(_scale))
		gui.set_parent(node,pnode)
		
	end


	plists={}
	
	for i=1,#nodes do
		local prio=nodes[i].priority or 0
		local p=plists[prio]
		if not p then p={} plists[prio]=p end
		p[#p+1]=nodes[i]
		p_max=math.max(p_max,prio)
		p_min=math.min(p_min,prio)
	end
	
end

function on_input(self, action_id, action)
	if  programdata.screen ~="associations" then return end

	if action_id==hash"text" and typeing_getstring and typeing_setstring then
		typeing_setstring(typeing_getstring()..action.text)
	end
	if action_id==hash"delete" and action.repeated and typeing_getstring and typeing_setstring then
		typeing_setstring(typeing_getstring():sub(1,#typeing_getstring()-1))
	end
	
	
	for i=p_max,p_min,-1 do
		local p=plists[i]
		if p then
		for i=1,#p do
			local nt=p[i]
			
			if action_id==hash"m1" and action.pressed then
				if gui.pick_node(nt.node, action.x, action.y) then
					if nt.clicked and nt.clicked() then goto exit end
				else
					if nt.clickoffed and nt.clickoffed() then goto exit end
				end
			end
			
		end
		end
	end

	::exit::
	
end
